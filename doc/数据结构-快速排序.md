### 数据结构-快速排序

#### 简介

快速排序在1960年提出，是考察次数最多的排序，无论是在大学专业课的期末考试，还是在公司的面试测试题目中，快速排序都极大的被使用，在实际中快速排序也极大的被使用。

#### 复杂度与稳定性

![微信图片_20201014142100](E:\source_code\datastruct\image\微信图片_20201014142100.jpg)



#### 过程介绍

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

1. 在数组中选择一个基准点pivot
2. 分别从数组的两端扫描数组，设两个指示标志left和right
3. 从后半部分开始遍历，如果元素>=基准元素，则right左移，如果元素<基准元素，则记录下标，为交换位置做准备
4. 然后从前半部分开始遍历，如果元素<=基准元素，则left右移，如果元素>基准元素，则记录下表，与right交换位置
5. 继续3，4的步骤，直到left和right重合，然后将基准点的元素和重合的元素交换位置，这样一轮保证基准点的左边元素都小于基准点的元素，基准点的右边元素都大于基准点的元素。
6. 以基准点为界，递归排序基准点左边的部分，然后再递归排序基准点右边的部分。



#### 详细分析

快速排序**在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。**

![image-20201014145404753](C:\Users\Administrator.USER-20190415PP\AppData\Roaming\Typora\typora-user-images\image-20201014145404753.png)

这种思路就叫做**分治法**。

每次把数列分成两部分，究竟有什么好处呢？

假如给定8个元素的数列，一般情况下冒泡排序需要比较8轮，每轮把一个元素移动到数列一端，时间复杂度是O（n^2）。

而快速排序的流程是什么样子呢？

![image-20201014150401860](E:\source_code\datastruct\image\image-20201014150401860.png)

原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。

这样一共需要多少轮呢？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 **O（nlogn）**。

**基准元素的选择**

基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边。

那么基准元素如何选择呢？

最简单的方式是选择数列的第一个元素

**元素的移动**

选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。

元素的移动有两种方法，我们这里用的是指针交换法。

什么是指针交换法？我们来看一看详细过程。

给定原始数列如下，要求从小到大排序：

![image-20201014160915229](E:\source_code\datastruct\image\image-20201014160915229.png)

我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：

![image-20201014161151478](E:\source_code\datastruct\image\image-20201014161151478.png)

接下来是**第一次循环**，从right指针开始，把指针所指向的元素和基准元素做比较。如果**大于等于**pivot，则指针向**左**移动；如果**小于**pivot，则right指针停止移动，切换到**left**指针。

在当前数列中，1<4，所以right直接停止移动，换到left指针，进行下一步行动。

轮到left指针行动，把指针所指向的元素和基准元素做比较。如果**小于等于**pivot，则指针向**右**移动；如果**大于**pivot，则left指针停止移动。

由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。

![image-20201014161252746](E:\source_code\datastruct\image\image-20201014161252746.png)

由于7 > 4，left指针在元素7的位置停下。这时候，我们让**left和right指向的元素进行交换**。

![image-20201014161403961](E:\source_code\datastruct\image\image-20201014161403961.png)

接下来，我们进入**第二次循环**，重新切换到right向左移动。right先移动到8，8>2，继续左移。由于2<8，停止在2的位置。

![image-20201014161544263](E:\source_code\datastruct\image\image-20201014161544263.png)

切换到left，6>4，停止在6的位置。

![image-20201014161630584](E:\source_code\datastruct\image\image-20201014161630584.png)

元素6和2交换。

![image-20201014161717860](E:\source_code\datastruct\image\image-20201014161717860.png)

进入**第三次循环**，right移动到元素3停止，left移动到元素5停止。

![image-20201014161755474](E:\source_code\datastruct\image\image-20201014161755474.png)

元素5和3交换。

![image-20201014161834932](E:\source_code\datastruct\image\image-20201014161834932.png)

进入**第四次循环**，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。

![image-20201014161909011](E:\source_code\datastruct\image\image-20201014161909011.png)

当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。

![image-20201014161952437](E:\source_code\datastruct\image\image-20201014161952437.png)

#### 代码实现

```java
package com.lwq.sort;

import java.util.Arrays;

/**
 * @author: LWQ
 * @create: 2020/10/14
 * @description: QuickSort
 **/
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {4, 7, 6, 5, 3, 2, 8, 1};
        System.out.println("排序前数组~~");
        System.out.println(Arrays.toString(arr));
        quickSort(arr, 0, 7);
        System.out.println("排序后数组~~");
        System.out.println(Arrays.toString(arr));
    }


    public static void quickSort(int[] arr, int start, int end) {
        // 左右已经重合了
        if (start >= end) {
            return;
        }
        // 先开始第一轮排序
        // 选择一个基准元素，我们选择第一个作为基准元素
        int pivot = start;
        // 左右都设置一个指针，来辅助遍历
        int left = start;
        int right = end;
        // 开始遍历元素，遍历结束的条件就是左右指针重合
        while (left != right) {
            // 先从右边开始遍历
            // 循环向左遍历，直到找到比基准元素小的元素
            // 或者left和right重合
            while (arr[right] >= arr[pivot] && right > left) {
                right--;
            }
            // 再从左边开始遍历
            // 循环向右遍历，直到找到比基准元素大的元素
            // 或者left和right重合
            while (arr[left] <= arr[pivot] && left < right) {
                left++;
            }

            // 交换元素
            if (left < right) {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
            }
        }
        // 如果left==right，将left与pivot元素交换位置
        if (left == right) {
            int temp = arr[left];
            arr[left] = arr[pivot];
            arr[pivot] = temp;
        }
        // 递归遍历左边部分
        quickSort(arr, start, left);
        // 递归遍历右边部分
        quickSort(arr, left + 1, end);
    }
}
```